package module

import modulepb "github.com/maxlandon/wiregost/proto/v1/gen/go/module"

// Exploit - A module dedicated to exploitation activities. Like other module types, when an exploit
// module is executed by the user, a higher level function ExploitDriver() takes care of initiating
// and monitoring the full exploitation process, from setup to session registration and exit.
// Therefore, although many methods of the exploit.Module type will not be available because it
// hides behind a Module interface, they will still be executed behind the scenes.
type Exploit struct {
	// Base module. Allows us to us the module's logging system. The exploit driver
	// will decide, based on user choices, if the local debugging (happening in
	// most of these functions below) should be pushed back to the user console.
	*module

	// Includes a payload
	Payload *Payload

	// Includes some targets. Targets should be an object accepting various things
	// (URLs, IPs, ranges, etc.), and they would be processed by this Exploit, and
	// used by the ExploitDriver running the exploit.
	Targets []string

	// Timeout and performance settings
}

// NewExploit - Instantiates an exploit module inheriting base functionality from the module.Module object.
func NewExploit() (m *Exploit) {
	return
}

// Init - Module initialization process: parses metadata/information, register options. It is called
// by the Stack binary, which then sends back module information as Protobuf to the server.
// Again, the function is called in the server, before the exploit is handled over to its driver.
// Maybe we should pass a pointer to the Stack binary state. So that it can register its logging system.
// EXPORTED
func (m *Exploit) Init(meta *modulepb.Info) (err error) {

	// Parses the protobuf metadata (base module function)
	err = m.information(meta)

	// Checks various fields and adds some if needed. (Type-specific)
	meta.Type = modulepb.Type_EXPLOIT // Set module type

	// Setup logger here. It should be somehow hooked to the stack binary
	// gRPC connection with the Module Manager, with the ModuleLog stream.

	// The logger cannot be initiated from the module.Module base type,
	// because the method is unexported, and therefore cannot be called
	// from the stack binary.
	// Depending on which binary is calling this function we might pass
	// it a different logger (on the server a local one, on stack a remote)
	var isRemote bool
	if isRemote {
		// This instance is on the stack binary: start logger wired to gRPC.
	} else {
		// This instance is on the server: start a local logger.
	}

	return nil
}

// - Adds default options for things like Payload path, etc.

// - Check default targets

// - Process given string targets: we should have a detailed & modular function for this.
//   In another vein, we should have many functions for different use cases.

// Compatibility methods (check targets against payloads, output lists of them, etc.)

// Setup - Prepares the module for exploitation, initializes any needed state.
func (m *Exploit) Setup() (err error) {

	// Configure the associated payload handler

	// Start the handler if reverse, return if bind (we don't want to start it now)

	return
}

// GeneratePayload - This function instructs the Payload field to generate itself, according to its
// current settings (which could be set from the exploit module), and manages its resulting state.
func (m *Exploit) GeneratePayload() (err error) {
	return
}

// Cleanup - Clean any state needed for this module, such as connections and handlers.
func (m *Exploit) Cleanup() (err error) {

	return
}

// runExploit - This function is unexported, because it should never be called directly
// by any subtypes (module writtens by other parties...during other parties).
func (m *Exploit) runExploit() (err error) {
	return
}
