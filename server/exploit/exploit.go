package exploit

import (
	"github.com/maxlandon/wiregost/server/module"
	"github.com/maxlandon/wiregost/server/module/stack"

	pb "github.com/maxlandon/wiregost/proto/v1/gen/go/module"
)

// Module - A module dedicated to exploitation activities. Like other module types, when an exploit
// module is executed by the user, a higher level function ExploitDriver() takes care of initiating
// and monitoring the full exploitation process, from setup to session registration and exit.
// Therefore, although many methods of the exploit.Module type will not be available because it
// hides behind a Module interface, they will still be executed behind the scenes.
type Module struct {
	// Base module. Makes this Exploit a valid module in Wiregost, with full access to UI.
	*module.Module

	// Includes a payload, maybe not needed, because the Exploit itself is not in charge of it.
	// Including the fact that an instance of this Exploit running on the stack binary doesn't need it.

	// Includes some targets. Targets should be an object accepting various things
	// (URLs, IPs, ranges, etc.), and they would be processed by this Exploit, and
	// used by the ExploitDriver running the exploit.
	Targets []string

	// Timeout and performance settings

}

// New - Instantiates an exploit module inheriting base functionality from the module.Module object.
// Let the game begin...
func New(meta *pb.Info) (m *Module) {
	m = &Module{
		module.New(meta), // Create base module
		[]string{},       // Empty targets.
	}

	m.Info.Type = pb.Type_EXPLOIT // Set module type

	// Setup logger: the m.SetupLog() asks the embedded module to automatically instantiate
	// a Logger depending on whether this exploit module needs a peer on the stack.
	// We then add fields specific to it, without modifying the log infrastructure.
	m.Log = m.Log.WithField("module", "exploit")

	return
}

// Setup - Prepares the module for exploitation, initializes any needed state, and more importantly,
// returns an object with which we synchronize the module remote stack peer, if there's one.
func (m *Module) Setup() (err error) {

	// Configure the associated payload handler

	// Start the handler if reverse, return if bind (we don't want to start it now)

	// Send full configuration to remote module, or return the config to the Driver

	return
}

// - Adds default options for things like Payload path, etc.
// Compatibility methods (check targets against payloads, output lists of them, etc.)

// - Check default targets

// - Process given string targets: we should have a detailed & modular function for this.
//   In another vein, we should have many functions for different use cases.

// AddModule - Implements the stack.Module interface. The Exploit
// handles a Module he's been given: he checks if the module is a
// Transport, and then checks its compability
func (m *Module) AddModule(mod stack.Module) (ok bool, err error) {
	// We cannot integrate a Payload module into an exploit,
	// nothing bad with that we will notify it and use the mod
	// as the new Current module.
	if mod.ToProtobuf().Info.Type == pb.Type_PAYLOAD {
		return false, nil
	}
	if mod.ToProtobuf().Info.Type == pb.Type_POST {
		return false, nil
	}

	// Check for transport, just in case...
	if mod.ToProtobuf().Info.Type == pb.Type_TRANSPORT {

		// Perform various checks for compatibility.

		// Then add the Transport
	}
	return
}

// SetOption - Implements the stack.Module interface. The Exploit
// checks in its sub-modules for this option.
func (m *Module) SetOption(opt *pb.Option) (err error) {

	if option, found := m.Opts[opt.Name]; found {
		err = option.Set(opt.Value)
	}

	// We came here, there might be an error but we must
	// check for other categories first: transports

	return
}

// Run - This function will be further implemented by all types embedding a Module.
// However, this function is useful because it will allow Stacks (server & binary)
// to call the implemented function at diverse layers, depending on needs.
func (m *Module) Run(cmd string, args []string) (result string, err error) {

	return
}

// Cleanup - Clean any state needed for this exploit, such as connections and handlers.
func (m *Module) Cleanup() (err error) {

	return
}
