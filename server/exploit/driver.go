package exploit

import "github.com/maxlandon/wiregost/server/transport"

// Driver - Drives the exploitation process from start to finish for a given
// exploit module instance. It's responsible for payload selection, configuration
// and generation, initializes handlers and finally runs the exploit, with all the
// associated setup steps (logging, security checks, etc...).
//
// There is one driver per exploit module loaded, per user. The exploit driver requests
// modules from the module.Manager, for populating its "template" and runs all appropriate
// components, checks compatibility between exploits, targets and payloads, etc...
//
// To some extent, all module types should have an underlying driver, for a better and
// more controlled exploitation process.
type Driver struct {
	// An exploit module, that might (or might not) trigger remote actions.
	Exploit *Module

	// Has access to a Payload object, provided by the Driver when instanciating.
	// This payload is also managed by the PayloadDriver, and might include only
	// one Transport, used by the Exploit.
	// Payload *Payload

	// Transports. They are handled and stored by the driver because they will be used by it
	// in different cases: for compiling implants with these transports information, as well
	// starting handlers based on them, which will need the routing system to work correctly.
	// Might need some route chains as well.
	Transports []*transport.Transport

	// Includes some targets (URLs, IPs, ranges, etc.), their string
	// values are generally passed on from the Exploit or the Payload,
	// and they are processed and monitored by the driver
	Targets   []string
	targetIdx int // Index of the current target in Targets

	// Some options, like backgrounding, logging, handlers settings, etc...
	KeepHandler bool // If exploit has multiple targets, we reuse the same handler.

	// User requesting it, for checking permissions, etc...

	// We use a reference to a Session/Ghost object (via a pointer). This object
	// will be used if our exploit triggers a session, in case we might have to
	// setup this session for some stuff, invoke methods on it for complete
	// registration, etc.
	// Will be needed by Transports.
	Session *string
}

// NewDriver - Instantiate the driver with some core information and components.
// The manager is passed in so that the Driver can access its gRPC client methods, for
// talking to the stack binary module and running its main function.
func NewDriver() (driver *Driver) {

	driver = &Driver{}

	// Instantiation of base items like logging, etc

	return
}

// Input validation methods (exploit compatibility, payload platform, options, security checks, etc)

// Validate - Gathers all validation methods that need to be triggered before exploit execution.
// These methods might be either ones of the Driver itself, or ones of the Exploit and Payload.
func (d *Driver) Validate() (err error) {

	// Validate modules are identical

	// Validate targets are setup and processed

	// Valide payload compatibility, and selected (cannot be nil)

	// Link the exploit to the payload instance, if needed

	// Validate options are set and values correct

	// Validate command given by user when running the module

	return
}

// CompatiblePayload - Verifies the Payload instance is compatible with the module's imposed targets.
func (d *Driver) CompatiblePayload() (ok bool) {

	return
}

// ModulesIdentical - Checks that both the server's module instance has a set of informations, targets,
// commands and options identical to the stack binary instance: This should ensure (at least partially)
// that no component on the remote module will use unexisting or misconfigured components.
// This function, for ease, should use hash functions to check signatures directly: the module should
// be, we assume, identical in everything.
func (d *Driver) ModulesIdentical() (ok bool) {

	// Check Exploit

	// Check payload and/or subcomponents, if needed

	return
}

// Run - This function asks the module instance running on the stack binary to execute.
// The stack module will do its thing, pushing events to consoles, using Wiregost' services for various
// things and, either returning successfully with a result or prematurely with an error, it will hand
// over the exploitation process back to this Driver.
func (d *Driver) Run(cmd string, args []string) (result string, err error) {

	// Validate everything with Validate()

	// Setup first target if needed. Maybe we might have to share
	// the targets to a higher level of Wiregost, because if exploits use
	// other components such as Dialers (for remote exploits), all of these
	// components will need to access the module's targets.

	// Setup Session if needed

	var useJob bool
	// If Job is to be run as a background job, prepare the job here and launch it.
	if useJob {
		// Since references to the exploit and payload will hang around for
		// awhile in the job, make sure we copy them so further changes to
		// the datastore don't alter settings in existing jobs.
		go d.runAsJob("", []string{})
	}

	// (Here, Metasploit generates a payload for the module's new instance)
	// But we might not have to deal with this, if we assume that state is correctly
	// shared among goroutines. Therefore we won't have to do copies of everything, etc...

	// Otherwise, we start the runAsJob function, without concurrency
	result, err = d.runAsJob("", []string{})

	return
}

// runAsJob - Called by Run(), will adapt the process slightly, for running it concurrently.
func (d *Driver) runAsJob(cmd string, args []string) (result string, err error) {

	// Setup the exploit if it needs to run some methods pre-run

	// Send ModuleRun event to Events System

	// Create a new exploit job and register it to server jobs.

	// RUN THE EXPLOIT

	// If the exploit Transport is a Dialer, then.. dial the antilope.

	return
}
